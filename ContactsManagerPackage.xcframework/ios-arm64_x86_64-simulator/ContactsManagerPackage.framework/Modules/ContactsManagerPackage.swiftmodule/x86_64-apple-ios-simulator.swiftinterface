// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-ios18.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name ContactsManagerPackage
import Combine
import Contacts
@_exported import ContactsManagerPackage
import CryptoKit
import Foundation
import OSLog
import Swift
import SwiftData
import SwiftUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _SwiftData_SwiftUI
@_hasMissingDesignatedInitializers public class CNContactMapper {
  @objc deinit
}
public enum ContactsSchemaVersions {
  public static let v1: ContactsManagerPackage.SchemaVersion
  public static let v2: ContactsManagerPackage.SchemaVersion
}
public enum ContactsMigrationStages {
  public static let v1ToV2: ContactsManagerPackage.MigrationStage
}
public struct ContactsMigrationPlan {
  public static let current: ContactsManagerPackage.SchemaMigrationPlan
}
extension ContactsManagerPackage.MigrationManager {
  public static var contacts: ContactsManagerPackage.MigrationManager {
    get
  }
  public static func contacts(databaseName: Swift.String, shouldHideDatabase: Swift.Bool = true) -> ContactsManagerPackage.MigrationManager
}
final public class MigrationManager {
  public init(migrationPlan: ContactsManagerPackage.SchemaMigrationPlan, userDefaults: Foundation.UserDefaults = .standard, versionKey: Swift.String = "com.contactsmanager.schema.version", databaseName: Swift.String = "ContactsManager.store", shouldHideDatabase: Swift.Bool = true)
  final public func createModelContainer() throws -> SwiftData.ModelContainer
  @objc deinit
}
public enum MigrationError : Foundation.LocalizedError {
  case invalidSchemaVersion(Swift.Int)
  case noMigrationPath(fromVersion: Swift.Int, toVersion: Swift.Int)
  case databaseCreationFailed(any Swift.Error)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct SchemaVersion {
  public let version: Swift.Int
  public let models: [any SwiftData.PersistentModel.Type]
  public init(version: Swift.Int, models: [any SwiftData.PersistentModel.Type])
}
public struct MigrationStage {
  public let fromVersion: Swift.Int
  public let toVersion: Swift.Int
  public let migrationHandler: (SwiftData.ModelContainer) async throws -> Swift.Void
  public init(fromVersion: Swift.Int, toVersion: Swift.Int, migrationHandler: @escaping (SwiftData.ModelContainer) async throws -> Swift.Void)
}
public struct SchemaMigrationPlan {
  public let schemaVersions: [ContactsManagerPackage.SchemaVersion]
  public let migrationStages: [ContactsManagerPackage.MigrationStage]
  public let currentVersion: Swift.Int
  public init(schemaVersions: [ContactsManagerPackage.SchemaVersion], migrationStages: [ContactsManagerPackage.MigrationStage], currentVersion: Swift.Int)
  public func migrationPath(fromVersion: Swift.Int, toVersion: Swift.Int) -> [ContactsManagerPackage.MigrationStage]
  public func schemaVersion(for version: Swift.Int) -> ContactsManagerPackage.SchemaVersion?
}
public let SECTIONNONAME: Swift.String
final public class Contact {
  final public var identifier: Swift.String {
    get
    set
  }
  final public var id: Swift.String {
    get
  }
  final public var contactType: Swift.Int {
    get
    set
  }
  final public var namePrefix: Swift.String? {
    get
    set
  }
  final public var givenName: Swift.String? {
    get
    set
  }
  final public var middleName: Swift.String? {
    get
    set
  }
  final public var familyName: Swift.String? {
    get
    set
  }
  final public var previousFamilyName: Swift.String? {
    get
    set
  }
  final public var nameSuffix: Swift.String? {
    get
    set
  }
  final public var nickname: Swift.String? {
    get
    set
  }
  final public var contactSection: Swift.String? {
    get
    set
  }
  final public var displayName: Swift.String? {
    get
    set
  }
  final public var organizationName: Swift.String? {
    get
    set
  }
  final public var departmentName: Swift.String? {
    get
    set
  }
  final public var jobTitle: Swift.String? {
    get
    set
  }
  final public var notes: Swift.String? {
    get
    set
  }
  final public var bio: Swift.String? {
    get
    set
  }
  final public var location: Swift.String? {
    get
    set
  }
  final public var imageUrl: Swift.String? {
    get
    set
  }
  final public var imageData: Foundation.Data? {
    get
    set
  }
  final public var thumbnailImageData: Foundation.Data? {
    get
    set
  }
  final public var imageDataAvailable: Swift.Bool {
    get
    set
  }
  final public var phoneNumbers: [ContactsManagerPackage.ContactLabelledValue] {
    get
    set
  }
  final public var emailAddresses: [ContactsManagerPackage.ContactLabelledValue] {
    get
    set
  }
  final public var urlAddresses: [ContactsManagerPackage.ContactLabelledValue] {
    get
    set
  }
  final public var socialProfiles: [ContactsManagerPackage.ContactSocial] {
    get
    set
  }
  final public var addresses: [ContactsManagerPackage.ContactAddress] {
    get
    set
  }
  final public var education: [ContactsManagerPackage.ContactEducation] {
    get
    set
  }
  final public var organizations: [ContactsManagerPackage.ContactOrganization] {
    get
    set
  }
  final public var interests: [Swift.String] {
    get
    set
  }
  final public var avatars: [Swift.String] {
    get
    set
  }
  final public var birthday: Foundation.Date? {
    get
    set
  }
  final public var createdAt: Swift.Double {
    get
    set
  }
  final public var matchString: Swift.String? {
    get
    set
  }
  final public var isDeleted: Swift.Bool {
    get
    set
  }
  final public var parentContactId: Swift.String? {
    get
    set
  }
  public init(identifier: Swift.String = UUID().uuidString)
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.Contact> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.Contact>)
  @objc deinit
}
extension ContactsManagerPackage.Contact : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.Contact {
  final public func updateDisplayInfo()
}
extension ContactsManagerPackage.Contact {
  final public func setPhoneNumbers(_ numbers: [ContactsManagerPackage.ContactLabelledValue])
  final public func setEmailAddresses(_ emails: [ContactsManagerPackage.ContactLabelledValue])
  final public func setUrlAddresses(_ urls: [ContactsManagerPackage.ContactLabelledValue])
  final public func setSocialProfiles(_ profiles: [ContactsManagerPackage.ContactSocial])
  final public func setAddresses(_ addresses: [ContactsManagerPackage.ContactAddress])
  final public func setEducation(_ education: [ContactsManagerPackage.ContactEducation])
  final public func setOrganizations(_ organizations: [ContactsManagerPackage.ContactOrganization])
  final public func setInterests(_ interests: [Swift.String])
  final public func setAvatars(_ avatars: [Swift.String])
}
extension ContactsManagerPackage.Contact : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.Contact : Observation.Observable {
}
final public class ContactAddress : Swift.Comparable {
  final public var addressId: Swift.String {
    get
    set
  }
  final public var address1: Swift.String? {
    get
    set
  }
  final public var address2: Swift.String? {
    get
    set
  }
  final public var city: Swift.String? {
    get
    set
  }
  final public var county: Swift.String? {
    get
    set
  }
  final public var state: Swift.String? {
    get
    set
  }
  final public var country: Swift.String? {
    get
    set
  }
  final public var postalCode: Swift.String? {
    get
    set
  }
  final public var countryCode: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  public init(contactId: Swift.String?, address1: Swift.String?, address2: Swift.String?, city: Swift.String?, county: Swift.String?, state: Swift.String?, country: Swift.String?, postalCode: Swift.String?, countryCode: Swift.String?, type: Swift.String?, emoji: Swift.String? = "")
  public static func < (lhs: ContactsManagerPackage.ContactAddress, rhs: ContactsManagerPackage.ContactAddress) -> Swift.Bool
  final public func display(separator: Swift.String = ", ") -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.ContactAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.ContactAddress>)
  @objc deinit
}
extension ContactsManagerPackage.ContactAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.ContactAddress {
  public static func create(from item: Contacts.CNLabeledValue<Contacts.CNPostalAddress>, contactId: Swift.String?) -> ContactsManagerPackage.ContactAddress
}
extension ContactsManagerPackage.ContactAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.ContactAddress : Observation.Observable {
}
final public class ContactEducation : Swift.Comparable {
  final public var educationId: Swift.String {
    get
    set
  }
  final public var schoolName: Swift.String? {
    get
    set
  }
  final public var degree: Swift.String? {
    get
    set
  }
  final public var year: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  public init(contactId: Swift.String?, schoolName: Swift.String?, degree: Swift.String?, year: Swift.String?, type: Swift.String?, emoji: Swift.String? = "")
  public static func < (lhs: ContactsManagerPackage.ContactEducation, rhs: ContactsManagerPackage.ContactEducation) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.ContactEducation> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.ContactEducation>)
  @objc deinit
}
extension ContactsManagerPackage.ContactEducation : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.ContactEducation : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.ContactEducation : Observation.Observable {
}
final public class ContactLabelledValue : Swift.Comparable {
  final public var labelId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var _value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  public init(contactId: Swift.String?, value: Swift.String?, type: Swift.String?, emoji: Swift.String?)
  public static func < (lhs: ContactsManagerPackage.ContactLabelledValue, rhs: ContactsManagerPackage.ContactLabelledValue) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.ContactLabelledValue> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.ContactLabelledValue>)
  @objc deinit
}
extension ContactsManagerPackage.ContactLabelledValue : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.ContactLabelledValue : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.ContactLabelledValue : Observation.Observable {
}
final public class ContactOrganization : Swift.Comparable {
  final public var organizationId: Swift.String {
    get
    set
  }
  final public var organizationName: Swift.String? {
    get
    set
  }
  final public var role: Swift.String? {
    get
    set
  }
  final public var department: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  public init(contactId: Swift.String?, organizationName: Swift.String?, role: Swift.String?, department: Swift.String?, type: Swift.String?, emoji: Swift.String? = "")
  public static func < (lhs: ContactsManagerPackage.ContactOrganization, rhs: ContactsManagerPackage.ContactOrganization) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.ContactOrganization> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.ContactOrganization>)
  @objc deinit
}
extension ContactsManagerPackage.ContactOrganization : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.ContactOrganization : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.ContactOrganization : Observation.Observable {
}
public enum ContactDataRestriction : Swift.String, Swift.CaseIterable {
  case notes
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ContactsManagerPackage.ContactDataRestriction]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ContactsManagerPackage.ContactDataRestriction] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ContactsManagerOptions {
  public let restrictedKeysToFetch: Swift.Set<ContactsManagerPackage.ContactFieldType>
  public static let `default`: ContactsManagerPackage.ContactsManagerOptions
  public init(restrictedKeysToFetch: Swift.Set<ContactsManagerPackage.ContactFieldType>)
}
final public class ContactSocial : Swift.Comparable {
  final public var socialId: Swift.String {
    get
    set
  }
  final public var urlString: Swift.String? {
    get
    set
  }
  final public var username: Swift.String? {
    get
    set
  }
  final public var userIdentifier: Swift.String? {
    get
    set
  }
  final public var service: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  public init(contactId: Swift.String?, urlString: Swift.String?, username: Swift.String?, userIdentifier: Swift.String?, service: Swift.String?, type: Swift.String?, emoji: Swift.String? = "")
  public static func < (lhs: ContactsManagerPackage.ContactSocial, rhs: ContactsManagerPackage.ContactSocial) -> Swift.Bool
  final public func display() -> Swift.String?
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManagerPackage.ContactSocial> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManagerPackage.ContactSocial>)
  @objc deinit
}
extension ContactsManagerPackage.ContactSocial : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManagerPackage.ContactSocial : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManagerPackage.ContactSocial : Observation.Observable {
}
public enum ContactsAccessStatus : Swift.Equatable {
  case notDetermined
  case authorized
  case limitedAuthorized
  case denied
  case restricted
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ContactsManagerPackage.ContactsAccessStatus, b: ContactsManagerPackage.ContactsAccessStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactSearchService {
  public static let shared: ContactsManagerPackage.ContactSearchService
  final public func initialize(with container: any ContactsManagerPackage.ContactDatabaseContainer)
  final public func searchContacts(query: Swift.String, searchFields: Swift.Set<ContactsManagerPackage.ContactSearchService.SearchField> = Set(SearchField.allCases), offset: Swift.Int = 0, limit: Swift.Int = 50) async throws -> [ContactsManagerPackage.Contact]
  public enum SearchField : Swift.CaseIterable {
    case name
    case email
    case phone
    case address
    case organization
    case notes
    public static func == (a: ContactsManagerPackage.ContactSearchService.SearchField, b: ContactsManagerPackage.ContactSearchService.SearchField) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [ContactsManagerPackage.ContactSearchService.SearchField]
    nonisolated public static var allCases: [ContactsManagerPackage.ContactSearchService.SearchField] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public protocol ContactDatabaseContainer {
  var mainContext: SwiftData.ModelContext { get }
}
@_hasMissingDesignatedInitializers final public class ContactService {
  public static let shared: ContactsManagerPackage.ContactService
  final public var contactsPublisher: Combine.AnyPublisher<Swift.Void, Swift.Never> {
    get
  }
  final public func initialize(with container: any ContactsManagerPackage.ContactDatabaseContainer)
  final public func requestAccess() async -> Swift.Bool
  final public func authorizationStatus() -> ContactsManagerPackage.ContactsAccessStatus
  final public func requestFullAccess() async -> Swift.Bool
  final public func fetchContacts(query: Swift.String? = nil, section: Swift.Character? = nil, offset: Swift.Int = 0, limit: Swift.Int = 50) async throws -> [ContactsManagerPackage.Contact]
  @objc deinit
}
extension SwiftData.ModelContainer : ContactsManagerPackage.ContactDatabaseContainer {
}
public enum ContactsManagerEvent : Swift.String {
  case appDidBecomeActive
  case appDidEnterBackground
  case contactStoreDidChange
  case appWasTerminated
  case contactsAccessChanged
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias EventHandler = () -> Swift.Void
@_hasMissingDesignatedInitializers final public class EventWrapperService : Foundation.ObservableObject {
  public static let shared: ContactsManagerPackage.EventWrapperService
  final public func subscribe(to event: ContactsManagerPackage.ContactsManagerEvent, identifier: Swift.String, handler: @escaping ContactsManagerPackage.EventHandler)
  final public func unsubscribe(from event: ContactsManagerPackage.ContactsManagerEvent, identifier: Swift.String)
  final public func startObserving()
  final public func stopObserving()
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
extension ContactsManagerPackage.ContactsManagerEvent : Swift.CaseIterable {
  public typealias AllCases = [ContactsManagerPackage.ContactsManagerEvent]
  nonisolated public static var allCases: [ContactsManagerPackage.ContactsManagerEvent] {
    get
  }
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onContactsManagerEvent(_ event: ContactsManagerPackage.ContactsManagerEvent, identifier: Swift.String, perform action: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
}
public enum ContactSelectionMode {
  case single
  case multiple
  public static func == (a: ContactsManagerPackage.ContactSelectionMode, b: ContactsManagerPackage.ContactSelectionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ContactFieldType {
  case notes
  case phone
  case email
  case any
  public static func == (a: ContactsManagerPackage.ContactFieldType, b: ContactsManagerPackage.ContactFieldType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactSelectionOptions {
  public let selectionMode: ContactsManagerPackage.ContactSelectionMode
  public let fieldType: ContactsManagerPackage.ContactFieldType
  public let maxSelectionCount: Swift.Int?
  public init(selectionMode: ContactsManagerPackage.ContactSelectionMode = .single, fieldType: ContactsManagerPackage.ContactFieldType = .any, maxSelectionCount: Swift.Int? = nil)
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public class ContactsManagerUI {
  public static func getInstance() -> ContactsManagerPackage.ContactsManagerUI
  public func searchContacts(from viewController: UIKit.UIViewController, options: ContactsManagerPackage.ContactSelectionOptions, completion: @escaping (Swift.Result<[ContactsManagerPackage.Contact], any Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum ContactsManagerError : Foundation.LocalizedError {
  case invalidAPIKey
  case initializationFailed(any Swift.Error)
  case databaseError(any Swift.Error)
  case notInitialized
  case contactsAccessDenied
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactsManager {
  public static let shared: ContactsManagerPackage.ContactsManager
  final public func initialize(withAPIKey apiKey: Swift.String, options: ContactsManagerPackage.ContactsManagerOptions = .default) async throws
  final public var isInitialized: Swift.Bool {
    get
  }
  final public var currentState: Swift.String {
    get
  }
  final public func reset() async throws
  final public var settingsAlert: some SwiftUICore.View {
    get
  }
  @objc deinit
}
extension ContactsManagerPackage.ContactsManager {
  final public func fetchContacts(fieldType: ContactsManagerPackage.ContactFieldType) async throws -> [ContactsManagerPackage.Contact]
  final public func fetchContact(withId id: Swift.String) async throws -> ContactsManagerPackage.Contact?
}
extension ContactsManagerPackage.ContactDataRestriction : Swift.Equatable {}
extension ContactsManagerPackage.ContactDataRestriction : Swift.Hashable {}
extension ContactsManagerPackage.ContactDataRestriction : Swift.RawRepresentable {}
extension ContactsManagerPackage.ContactsAccessStatus : Swift.Hashable {}
extension ContactsManagerPackage.ContactSearchService.SearchField : Swift.Equatable {}
extension ContactsManagerPackage.ContactSearchService.SearchField : Swift.Hashable {}
extension ContactsManagerPackage.ContactsManagerEvent : Swift.Equatable {}
extension ContactsManagerPackage.ContactsManagerEvent : Swift.Hashable {}
extension ContactsManagerPackage.ContactsManagerEvent : Swift.RawRepresentable {}
extension ContactsManagerPackage.ContactSelectionMode : Swift.Equatable {}
extension ContactsManagerPackage.ContactSelectionMode : Swift.Hashable {}
extension ContactsManagerPackage.ContactFieldType : Swift.Equatable {}
extension ContactsManagerPackage.ContactFieldType : Swift.Hashable {}
