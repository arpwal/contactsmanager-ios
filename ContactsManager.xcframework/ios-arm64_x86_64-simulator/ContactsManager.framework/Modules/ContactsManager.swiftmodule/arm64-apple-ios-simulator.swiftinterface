// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios18.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name ContactsManager
import BackgroundTasks
import Combine
import Contacts
@_exported import ContactsManager
import CryptoKit
import Foundation
import OSLog
import Observation
import Swift
import SwiftData
import SwiftUI
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _SwiftData_SwiftUI
public enum ContactDatabaseError : Swift.Error {
  case notInitialized
  case invalidModelContainer
  case contactNotFound
  case invalidData
  case searchError
  case operationFailed(Swift.String)
  case contextCreationFailed
}
public enum ContactSyncProperty {
  case sourceId(Swift.String)
  case parentContactId(Swift.String)
  case imageUrl(Swift.String)
  case bio(Swift.String)
  case location(Swift.String)
  case organizationName(Swift.String)
  case departmentName(Swift.String)
  case jobTitle(Swift.String)
  case notes(Swift.String)
  case interests([Swift.String])
  case avatars([Swift.String])
  case isDeleted(Swift.Bool)
}
extension ContactsManager.ContactsService {
  final public func enableBackgroundSync()
  final public func scheduleBackgroundSyncTask()
}
extension ContactsManager.ContactsService {
  final public func fetchContacts(fieldType: ContactsManager.ContactFieldType) async throws -> [ContactsManager.CMContact]
  final public func fetchContact(withId id: Swift.String) async throws -> ContactsManager.CMContact?
  final public func fetchCNContact(withIdentifier identifier: Swift.String) async -> Contacts.CNContact?
}
extension ContactsManager.ContactsService {
  final public func getSharedContactsByUsersToInvite(limit: Swift.Int = 30) async throws -> [ContactsManager.ContactRecommendation]
  final public func getContactsUsingApp(limit: Swift.Int = 30) async throws -> [ContactsManager.Contact]
  final public func getUsersYouMightKnow(limit: Swift.Int = 30) async throws -> [ContactsManager.CMUser]
}
extension ContactsManager.ContactsService {
  final public func syncContacts() async throws -> Swift.Int
}
extension ContactsManager.Contact {
  public static func from(cmContact: ContactsManager.CMContact, contactId: Swift.String? = nil, localContactId: Swift.String? = nil) -> ContactsManager.Contact
  public static func from(cmContacts: [ContactsManager.CMContact]) -> [ContactsManager.Contact]
  public var isFromCMContact: Swift.Bool {
    get
  }
  public var hasCMContact: Swift.Bool {
    get
  }
}
extension ContactsManager.Contact {
  public static func from(cmUser: ContactsManager.CMUser, contactId: Swift.String? = nil, localContactId: Swift.String? = nil) async -> ContactsManager.Contact
  public static func from(cmUsers: [ContactsManager.CMUser]) async -> [ContactsManager.Contact]
  public var isFromCMUser: Swift.Bool {
    get
  }
  public var hasCMUser: Swift.Bool {
    get
  }
  public var hasLocalAndCanonicalData: Swift.Bool {
    get
  }
  public var isFromLocalMatch: Swift.Bool {
    get
  }
}
extension ContactsManager.Contact {
  public var isUser: Swift.Bool {
    get
  }
  public var isLocalOnly: Swift.Bool {
    get
  }
  public var primaryDisplayName: Swift.String {
    get
  }
  public var primaryContactMethod: Swift.String? {
    get
  }
  public var allEmailAddresses: [Swift.String] {
    get
  }
  public var allPhoneNumbers: [Swift.String] {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public let SECTIONNONAME: Swift.String
final public class CMContact {
  final public var identifier: Swift.String {
    get
    set
  }
  final public var id: Swift.String {
    get
  }
  final public var contactType: Swift.Int {
    get
    set
  }
  final public var namePrefix: Swift.String? {
    get
    set
  }
  final public var givenName: Swift.String? {
    get
    set
  }
  final public var middleName: Swift.String? {
    get
    set
  }
  final public var familyName: Swift.String? {
    get
    set
  }
  final public var previousFamilyName: Swift.String? {
    get
    set
  }
  final public var nameSuffix: Swift.String? {
    get
    set
  }
  final public var nickname: Swift.String? {
    get
    set
  }
  final public var contactSection: Swift.String? {
    get
    set
  }
  final public var displayName: Swift.String? {
    get
    set
  }
  final public var organizationName: Swift.String? {
    get
    set
  }
  final public var departmentName: Swift.String? {
    get
    set
  }
  final public var jobTitle: Swift.String? {
    get
    set
  }
  final public var notes: Swift.String? {
    get
    set
  }
  final public var bio: Swift.String? {
    get
    set
  }
  final public var location: Swift.String? {
    get
    set
  }
  final public var imageUrl: Swift.String? {
    get
    set
  }
  final public var imageData: Foundation.Data? {
    get
    set
  }
  final public var thumbnailImageData: Foundation.Data? {
    get
    set
  }
  final public var imageDataAvailable: Swift.Bool {
    get
    set
  }
  final public var phoneNumbers: [ContactsManager.ContactPhoneNumber] {
    get
    set
  }
  final public var emailAddresses: [ContactsManager.ContactEmailAddress] {
    get
    set
  }
  final public var urlAddresses: [ContactsManager.ContactURLAddress] {
    get
    set
  }
  final public var socialProfiles: [ContactsManager.ContactSocial] {
    get
    set
  }
  final public var addresses: [ContactsManager.ContactAddress] {
    get
    set
  }
  final public var instantMessageAddresses: [ContactsManager.ContactInstantMessage] {
    get
    set
  }
  final public var relations: [ContactsManager.ContactRelation] {
    get
    set
  }
  final public var interests: [Swift.String] {
    get
    set
  }
  final public var avatars: [Swift.String] {
    get
    set
  }
  final public var birthday: Foundation.Date? {
    get
    set
  }
  final public var dates: [ContactsManager.ContactDate] {
    get
    set
  }
  final public var createdAt: Swift.Double {
    get
    set
  }
  final public var matchString: Swift.String? {
    get
    set
  }
  final public var isDeleted: Swift.Bool {
    get
    set
  }
  final public var parentContactId: Swift.String? {
    get
    set
  }
  final public var lastSyncedAt: Swift.Double? {
    get
    set
  }
  final public var dirtyTime: Swift.Double? {
    get
    set
  }
  final public var sourceId: Swift.String? {
    get
    set
  }
  public init(identifier: Swift.String = UUID().uuidString, firstName: Swift.String? = nil, lastName: Swift.String? = nil, sourceId: Swift.String? = nil)
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.CMContact> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.CMContact>)
  @objc deinit
}
extension ContactsManager.CMContact : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.CMContact {
  final public var displayInfo: Swift.String {
    get
  }
}
extension ContactsManager.CMContact : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.CMContact : Observation.Observable {
}
public struct CMUser : Swift.Codable, Swift.Identifiable, Swift.Hashable {
  public let id: Swift.String
  public let organizationId: Swift.String?
  public let organizationUserId: Swift.String
  public let email: Swift.String?
  public let phone: Swift.String?
  public let fullName: Swift.String?
  public let avatarUrl: Swift.String?
  public let isActive: Swift.Bool?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public var contactMetadata: [Swift.String : Any]? {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public var displayInfo: Swift.String {
    get
  }
  public var initials: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ContactsManager.CMUser, rhs: ContactsManager.CMUser) -> Swift.Bool
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public enum FollowingStatus : Swift.String {
  case following
  case follower
  case mutual
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Contact : Swift.Decodable, Swift.Identifiable {
  public let contactId: Swift.String
  public let localContactId: Swift.String
  public let cmContact: ContactsManager.CMContact?
  public let cmUser: ContactsManager.CMUser?
  public var id: Swift.String {
    get
  }
  public var userId: Swift.String? {
    get
  }
  public var displayName: Swift.String? {
    get
  }
  public var givenName: Swift.String? {
    get
  }
  public var familyName: Swift.String? {
    get
  }
  public var image: Swift.String? {
    get
  }
  public func getImageData() async -> UIKit.UIImage?
  public func getFollowingStatus() async -> ContactsManager.FollowingStatus?
  public func getLocalContact() async -> Contacts.CNContact?
  public init(from decoder: any Swift.Decoder) throws
  public typealias ID = Swift.String
}
@_hasMissingDesignatedInitializers final public class ContactAddress : Swift.Comparable {
  final public var addressId: Swift.String {
    get
    set
  }
  final public var address1: Swift.String? {
    get
    set
  }
  final public var address2: Swift.String? {
    get
    set
  }
  final public var city: Swift.String? {
    get
    set
  }
  final public var county: Swift.String? {
    get
    set
  }
  final public var state: Swift.String? {
    get
    set
  }
  final public var country: Swift.String? {
    get
    set
  }
  final public var postalCode: Swift.String? {
    get
    set
  }
  final public var countryCode: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactAddress, rhs: ContactsManager.ContactAddress) -> Swift.Bool
  final public func display(separator: Swift.String = ", ") -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactAddress>)
  @objc deinit
}
extension ContactsManager.ContactAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactAddress : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactDate : Swift.Codable {
  final public var id: Swift.String {
    get
    set
  }
  final public var contactId: Swift.String {
    get
    set
  }
  final public var label: Swift.String {
    get
    set
  }
  final public var date: Foundation.Date {
    get
    set
  }
  final public var isPrimary: Swift.Bool {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  final public func displayString() -> Swift.String
  final public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactDate> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactDate>)
  @objc deinit
}
extension ContactsManager.ContactDate : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactDate : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactEmailAddress : Swift.Comparable {
  final public var emailId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactEmailAddress, rhs: ContactsManager.ContactEmailAddress) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactEmailAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactEmailAddress>)
  @objc deinit
}
extension ContactsManager.ContactEmailAddress : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactEmailAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactEmailAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactEmailAddress : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactInstantMessage : Swift.Comparable {
  final public var instantMessageId: Swift.String {
    get
    set
  }
  final public var service: Swift.String? {
    get
    set
  }
  final public var username: Swift.String? {
    get
    set
  }
  final public var userIdentifier: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactInstantMessage, rhs: ContactsManager.ContactInstantMessage) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactInstantMessage> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactInstantMessage>)
  @objc deinit
}
extension ContactsManager.ContactInstantMessage : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactInstantMessage : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactInstantMessage : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactPhoneNumber : Swift.Comparable {
  final public var phoneId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactPhoneNumber, rhs: ContactsManager.ContactPhoneNumber) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactPhoneNumber> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactPhoneNumber>)
  @objc deinit
}
extension ContactsManager.ContactPhoneNumber : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactPhoneNumber : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactPhoneNumber : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactPhoneNumber : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactRelation : Swift.Comparable {
  final public var relationId: Swift.String {
    get
    set
  }
  final public var name: Swift.String? {
    get
    set
  }
  final public var relationType: Swift.String? {
    get
    set
  }
  final public var notes: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactRelation, rhs: ContactsManager.ContactRelation) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactRelation> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactRelation>)
  @objc deinit
}
extension ContactsManager.ContactRelation : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactRelation : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactRelation : Observation.Observable {
}
public enum ContactDataRestriction : Swift.String, Swift.CaseIterable {
  case notes
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ContactsManager.ContactDataRestriction]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ContactsManager.ContactDataRestriction] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ContactsManagerOptions {
  public let restrictedKeysToFetch: Swift.Set<ContactsManager.ContactFieldType>
  public let verboseLogging: Swift.Bool
  public let autoSyncEnabled: Swift.Bool
  public static let `default`: ContactsManager.ContactsManagerOptions
  public init(restrictedKeysToFetch: Swift.Set<ContactsManager.ContactFieldType> = [], verboseLogging: Swift.Bool = false, autoSyncEnabled: Swift.Bool = true)
}
@_hasMissingDesignatedInitializers final public class ContactSocial : Swift.Comparable {
  final public var socialId: Swift.String {
    get
    set
  }
  final public var urlString: Swift.String? {
    get
    set
  }
  final public var username: Swift.String? {
    get
    set
  }
  final public var userIdentifier: Swift.String? {
    get
    set
  }
  final public var service: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactSocial, rhs: ContactsManager.ContactSocial) -> Swift.Bool
  final public func display() -> Swift.String?
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactSocial> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactSocial>)
  @objc deinit
}
extension ContactsManager.ContactSocial : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactSocial : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactSocial : Observation.Observable {
}
public enum SourceType : Swift.String, Swift.Codable {
  case google
  case outlook
  case csv
  case api
  case device
  case other
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactSource {
  final public var id: Swift.String {
    get
    set
  }
  final public var name: Swift.String {
    get
    set
  }
  final public var sourceType: Swift.String {
    get
    set
  }
  final public var organizationId: Swift.String {
    get
    set
  }
  final public var canonicalContactId: Swift.String {
    get
    set
  }
  final public var isActive: Swift.Bool {
    get
    set
  }
  final public var lastSyncAt: Swift.Double? {
    get
    set
  }
  final public var syncError: Swift.String? {
    get
    set
  }
  final public var credentialsJSON: Swift.String? {
    get
    set
  }
  final public var settingsJSON: Swift.String? {
    get
    set
  }
  final public var sourceMetadataJSON: Swift.String? {
    get
    set
  }
  final public var createdAt: Swift.Double {
    get
    set
  }
  final public var updatedAt: Swift.Double {
    get
    set
  }
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactSource> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactSource>)
  @objc deinit
}
extension ContactsManager.ContactSource : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactSource : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactSource : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactURLAddress : Swift.Comparable {
  final public var urlId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.CMContact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactURLAddress, rhs: ContactsManager.ContactURLAddress) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactURLAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactURLAddress>)
  @objc deinit
}
extension ContactsManager.ContactURLAddress : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactURLAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactURLAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactURLAddress : Observation.Observable {
}
public struct DeviceInfo : Swift.Codable {
  public var deviceId: Swift.String
  public var hardwareId: Swift.String
  public var deviceName: Swift.String
  public var deviceModel: Swift.String
  public var deviceManufacturer: Swift.String
  public var deviceModelId: Swift.String
  public var osName: Swift.String
  public var osVersion: Swift.String
  public var screenWidth: Swift.Int
  public var screenHeight: Swift.Int
  public var screenDensity: CoreFoundation.CGFloat
  public var networkType: Swift.String
  public var appVersion: Swift.String
  public var appBuild: Swift.String
  public var appId: Swift.String
  public var locale: Swift.String
  public var timezone: Swift.String
  public var totalMemory: Swift.Int?
  public var cpuCount: Swift.Int?
  public var batteryLevel: Swift.Float?
  public var isCharging: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.DeviceInfo {
  public func asDictionary() -> [Swift.String : Any]
}
public struct FollowRelationship : Swift.Codable, Swift.Identifiable {
  public let id: Swift.String
  public let followerId: Swift.String
  public let followedId: Swift.String
  public let userId: Swift.String
  public let createdAt: Foundation.Date
  public let follower: ContactsManager.CMUser?
  public let followed: ContactsManager.CMUser?
  public var localContact: ContactsManager.CMContact?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Swift.String
}
public struct FollowActionResponse : Swift.Decodable {
  public let alreadyFollowing: Swift.Bool?
  public let wasFollowing: Swift.Bool?
  public let success: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public struct FollowStatusResponse : Swift.Decodable {
  public let isFollowing: Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedFollowList : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public var items: [ContactsManager.FollowRelationship]
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedMutualFollowers : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public var items: [ContactsManager.CMUser]
  public init(from decoder: any Swift.Decoder) throws
}
public struct InviteResponse : Swift.Codable {
  public let id: Swift.String
  public let inviteCode: Swift.String
  public let inviteUrl: Swift.String
  public let remainingInvites: Swift.Int
  public let isActive: Swift.Bool
  public let createdAt: Foundation.Date?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct InviteRedemptionRequest : Swift.Codable {
  public let inviteCode: Swift.String
  public let redeemerId: Swift.String
  public init(inviteCode: Swift.String, redeemerId: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InviteRedemptionResponse : Swift.Codable {
  public let success: Swift.Bool
  public let message: Swift.String
  public let inviterId: Swift.String?
  public let organizationId: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InvitedUserWithRedemption : Swift.Codable {
  public let cmUser: ContactsManager.CMUser
  public let redeemedAt: Foundation.Date
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct InvitedUsersResponse : Swift.Codable {
  public let invitedUsers: [ContactsManager.InvitedUserWithRedemption]
  public let totalInvited: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InviteStatsResponse : Swift.Codable {
  public let inviteLimit: Swift.Int
  public let invitesUsed: Swift.Int
  public let remainingInvites: Swift.Int
  public let hasActiveInvite: Swift.Bool
  public let activeInviteCode: Swift.String?
  public let activeInviteUrl: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InvitedByResponse : Swift.Codable {
  public let invitedBy: ContactsManager.CMUser?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ValidateInviteCodeRequest : Swift.Codable {
  public let inviteCode: Swift.String
  public init(inviteCode: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ValidateInviteCodeResponse : Swift.Codable {
  public let valid: Swift.Bool
  public let message: Swift.String
  public let inviter: ContactsManager.CMUser?
  public let organizationName: Swift.String?
  public let remainingInvites: Swift.Int?
  public init(valid: Swift.Bool, message: Swift.String, inviter: ContactsManager.CMUser? = nil, organizationName: Swift.String? = nil, remainingInvites: Swift.Int? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct BulkInviteEmailResponse : Swift.Codable {
  public let success: Swift.Bool
  public let message: Swift.String
  public let totalContacts: Swift.Int
  public let emailsSent: Swift.Int
  public let failedEmails: [Swift.String]
  public let inviteCode: Swift.String?
  public let inviteUrl: Swift.String?
  public init(success: Swift.Bool, message: Swift.String, totalContacts: Swift.Int, emailsSent: Swift.Int, failedEmails: [Swift.String] = [], inviteCode: Swift.String? = nil, inviteUrl: Swift.String? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ReactionType : Swift.Codable, Swift.Equatable, Swift.CaseIterable {
  case like
  case love
  case superLike
  case support
  case laugh
  case wow
  case sad
  case angry
  case custom(Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public init(rawValue: Swift.String)
  public static var allCases: [ContactsManager.ReactionType] {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public var emoji: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ContactsManager.ReactionType, b: ContactsManager.ReactionType) -> Swift.Bool
  public typealias AllCases = [ContactsManager.ReactionType]
}
public struct EventReaction : Swift.Codable, Swift.Identifiable {
  public let id: Swift.String
  public let reactionType: ContactsManager.ReactionType
  public let organizationId: Swift.String
  public let eventId: Swift.String
  public let userId: Swift.String
  public let user: ContactsManager.ReactionUser
  public let createdAt: Foundation.Date
  public let updatedAt: Foundation.Date
  public let metadata: ContactsManager.ReactionMetadata?
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ReactionUser : Swift.Codable {
  public let userId: Swift.String
  public let name: Swift.String?
  public let avatarUrl: Swift.String?
  public let reactedAt: Foundation.Date?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ReactionMetadata : Swift.Codable {
  public let comment: Swift.String?
  public let intensity: Swift.Int?
  public let customProperties: [Swift.String : Swift.String]?
  public init(comment: Swift.String? = nil, intensity: Swift.Int? = nil, customProperties: [Swift.String : Swift.String]? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ReactionTypeSummary : Swift.Codable {
  public let count: Swift.Int
  public let recentReactors: [ContactsManager.ReactionUser]
  public init(count: Swift.Int, recentReactors: [ContactsManager.ReactionUser])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EventReactionsSummary : Swift.Codable {
  public let reactionSummaries: [Swift.String : ContactsManager.ReactionTypeSummary]
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func count(for reactionType: ContactsManager.ReactionType) -> Swift.Int
  public var availableReactionTypes: [ContactsManager.ReactionType] {
    get
  }
  public var totalCount: Swift.Int {
    get
  }
  public func summary(for reactionType: ContactsManager.ReactionType) -> ContactsManager.ReactionTypeSummary?
  public var hasReactions: Swift.Bool {
    get
  }
}
public struct EventWithReactions : Swift.Codable, Swift.Identifiable {
  public let event: ContactsManager.SocialEvent
  public let reactionsSummary: ContactsManager.EventReactionsSummary
  public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreateReactionRequest : Swift.Codable {
  public let reactionType: ContactsManager.ReactionType
  public let metadata: ContactsManager.ReactionMetadata?
  public init(reactionType: ContactsManager.ReactionType, metadata: ContactsManager.ReactionMetadata? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ReactionActionResponse : Swift.Codable {
  public let reactionId: Swift.String?
  public let reactionType: ContactsManager.ReactionType?
  public let wasCreated: Swift.Bool?
  public let wasRemoved: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedReactionsList : Swift.Codable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public let reactions: [ContactsManager.EventReaction]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UserReactionResponse : Swift.Codable {
  public let reactionType: ContactsManager.ReactionType?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct BatchUserReactionsResponse : Swift.Codable {
  public let reactions: [Swift.String : ContactsManager.ReactionType?]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct BatchUserReactionsRequest : Swift.Codable {
  public let eventIds: [Swift.String]
  public init(eventIds: [Swift.String])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SocialEvent : Swift.Codable, Swift.Identifiable {
  public let id: Swift.String
  public let organizationId: Swift.String
  public let canonicalContactId: Swift.String
  public let eventType: Swift.String
  public let title: Swift.String
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool
  public let createdAt: Foundation.Date
  public let updatedAt: Foundation.Date
  public let userId: Swift.String?
  public let createdBy: ContactsManager.EventCreator?
  public let reactionsCount: Swift.Int?
  public let reactionsSummary: ContactsManager.EventReactionsSummary?
  public let reactionsLastUpdated: Foundation.Date?
  public let userReaction: ContactsManager.ReactionType?
  public var hasReactions: Swift.Bool {
    get
  }
  public var reactionsCountText: Swift.String {
    get
  }
  public func userHasReacted(with reactionType: ContactsManager.ReactionType) -> Swift.Bool
  public var userHasReacted: Swift.Bool {
    get
  }
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EventCreator : Swift.Codable {
  public let name: Swift.String?
  public let avatarUrl: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreateEventRequest : Swift.Codable {
  public let eventType: Swift.String
  public let title: Swift.String
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool
  public init(eventType: ContactsManager.SocialEventType, title: Swift.String, description: Swift.String? = nil, location: Swift.String? = nil, startTime: Foundation.Date? = nil, endTime: Foundation.Date? = nil, metadata: [Swift.String : Swift.String]? = nil, isPublic: Swift.Bool = true)
  public init(eventType: Swift.String, title: Swift.String, description: Swift.String? = nil, location: Swift.String? = nil, startTime: Foundation.Date? = nil, endTime: Foundation.Date? = nil, metadata: [Swift.String : Swift.String]? = nil, isPublic: Swift.Bool = true)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UpdateEventRequest : Swift.Codable {
  public let title: Swift.String?
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool?
  public init(title: Swift.String? = nil, description: Swift.String? = nil, location: Swift.String? = nil, startTime: Foundation.Date? = nil, endTime: Foundation.Date? = nil, metadata: [Swift.String : Swift.String]? = nil, isPublic: Swift.Bool? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EventActionResponse : Swift.Decodable {
  public let eventId: Swift.String?
  public let created: Swift.Bool?
  public let updated: Swift.Bool?
  public let deleted: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedEventList : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public let items: [ContactsManager.SocialEvent]
  public init(from decoder: any Swift.Decoder) throws
}
public enum FeedMatchingType : Swift.String, Swift.CaseIterable {
  case following
  case mutualFollowing
  case all
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ContactsManager.FeedMatchingType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ContactsManager.FeedMatchingType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum SocialEventType : Swift.String, Swift.CaseIterable {
  case post
  case photo
  case activity
  case checkIn
  case lifeEvent
  case recommendation
  case event
  public static let allTypes: [Swift.String]
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ContactsManager.SocialEventType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ContactsManager.SocialEventType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct SocialResponse<T> : Swift.Decodable where T : Swift.Decodable {
  public let status: Swift.String
  public let message: Swift.String?
  public let data: T
  public init(from decoder: any Swift.Decoder) throws
}
public class UserInfo : Swift.Codable {
  final public let userId: Swift.String
  final public let fullName: Swift.String?
  final public let email: Swift.String?
  final public let phone: Swift.String?
  final public let avatarUrl: Swift.String?
  final public let metadata: [Swift.String : Swift.String]?
  public init(userId: Swift.String, fullName: Swift.String? = nil, email: Swift.String? = nil, phone: Swift.String? = nil, avatarUrl: Swift.String? = nil, metadata: [Swift.String : Swift.String]? = nil)
  public func isValid() -> Swift.Bool
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum APIError : Swift.Error {
  case invalidURL
  case noData
  case decodingError
  case serverError(statusCode: Swift.Int, message: Swift.String)
  case networkError(any Swift.Error)
  case unauthorized
  case tokenExpired
  case unknownError
  public var localizedDescription: Swift.String {
    get
  }
}
public enum RuntimeEnvironment : Swift.String {
  case development
  case staging
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct APIConfig {
  public static var environment: ContactsManager.RuntimeEnvironment
  public static var baseURL: Foundation.URL {
    get
  }
  public static let apiVersion: Swift.String
  public static let contactsEndpoint: Swift.String
  public static let contactsSyncEndpoint: Swift.String
  public static let contactSourceEndpoint: Swift.String
  public static let canonicalContactEndpoint: Swift.String
  public static let canonicalContactsBatchEndpoint: Swift.String
  public static let generateTokenEndpoint: Swift.String
  public static let sharedContactsToInviteEndpoint: Swift.String
  public static let appUserContactsEndpoint: Swift.String
  public static let usersYouMightKnowEndpoint: Swift.String
  public static let socialBasePath: Swift.String
  public static let followEndpoint: Swift.String
  public static let unfollowEndpoint: Swift.String
  public static let isFollowingEndpoint: Swift.String
  public static let relationshipStatusEndpoint: Swift.String
  public static let followersEndpoint: Swift.String
  public static let followingEndpoint: Swift.String
  public static let mutualFollowsEndpoint: Swift.String
  public static let batchFollowingStatusEndpoint: Swift.String
  public static let eventsEndpoint: Swift.String
  public static let feedEndpoint: Swift.String
  public static let upcomingEventsEndpoint: Swift.String
  public static let forYouEndpoint: Swift.String
  public static let reactionsEndpoint: Swift.String
  public static let batchUserReactionsEndpoint: Swift.String
  public static let userInvitesBasePath: Swift.String
  public static let createInviteEndpoint: Swift.String
  public static let redeemInviteEndpoint: Swift.String
  public static let myInvitesEndpoint: Swift.String
  public static let inviteStatsEndpoint: Swift.String
  public static let validateInviteEndpoint: Swift.String
  public static let invitedByEndpoint: Swift.String
  public static let publicValidateInviteEndpoint: Swift.String
  public static let bulkInviteEmailEndpoint: Swift.String
  public static let bulkInviteEmailAvailableEndpoint: Swift.String
  public static let validateAPIKeyEndpoint: Swift.String
  public static let defaultTimeout: Swift.Double
  public static let uploadTimeout: Swift.Double
  public static let healthEndpoint: Swift.String
  public static let maxContactsPerBatch: Swift.Int
  public static let websiteURL: Swift.String
}
@_hasMissingDesignatedInitializers public class ContactSyncManager {
  public enum ContactSourceError : Swift.Error, Foundation.LocalizedError {
    case saveFailure(any Swift.Error)
    case retrievalFailure(Swift.String)
    case sourceNotFound
    case jsonEncodingFailure
    case jsonDecodingFailure
    public var errorDescription: Swift.String? {
      get
    }
  }
  @objc deinit
}
extension ContactsManager.ContactSyncManager {
  public enum SyncError : Swift.Error {
    case alreadyRunning
    case contextSaveError
    case sourceNotRegistered
    case organizationIdNotFound
    public var localizedDescription: Swift.String {
      get
    }
    public static func == (a: ContactsManager.ContactSyncManager.SyncError, b: ContactsManager.ContactSyncManager.SyncError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ContactDatabaseContainer {
  var mainContext: SwiftData.ModelContext { get }
}
extension SwiftData.ModelContainer : ContactsManager.ContactDatabaseContainer {
}
public enum ContactsAccessStatus : Swift.Equatable {
  case notDetermined
  case authorized
  case limitedAuthorized
  case denied
  case restricted
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ContactsManager.ContactsAccessStatus, b: ContactsManager.ContactsAccessStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactSearchService {
  public static let shared: ContactsManager.ContactSearchService
  final public func getTotalContactsCount() async throws -> Swift.Int
  final public func searchContacts(query: Swift.String, searchFields: Swift.Set<ContactsManager.ContactSearchService.SearchField> = Set(SearchField.allCases), offset: Swift.Int = 0, limit: Swift.Int = 50) async throws -> (contacts: [ContactsManager.CMContact], totalCount: Swift.Int)
  final public func quickSearch(_ query: Swift.String) async throws -> [ContactsManager.CMContact]
  public enum SearchField : Swift.CaseIterable {
    case name
    case email
    case phone
    case address
    case organization
    case notes
    public static func == (a: ContactsManager.ContactSearchService.SearchField, b: ContactsManager.ContactSearchService.SearchField) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [ContactsManager.ContactSearchService.SearchField]
    nonisolated public static var allCases: [ContactsManager.ContactSearchService.SearchField] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public enum ContactsManagerEvent : Swift.String {
  case appDidBecomeActive
  case appDidEnterBackground
  case contactStoreDidChange
  case appWasTerminated
  case contactsAccessChanged
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias EventHandler = () -> Swift.Void
extension ContactsManager.ContactsManagerEvent : Swift.CaseIterable {
  public typealias AllCases = [ContactsManager.ContactsManagerEvent]
  nonisolated public static var allCases: [ContactsManager.ContactsManagerEvent] {
    get
  }
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onContactsManagerEvent(_ event: ContactsManager.ContactsManagerEvent, identifier: Swift.String, perform action: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
}
public enum SocialServiceError : Foundation.LocalizedError {
  case invalidInput(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class SocialService {
  public struct BatchFollowingStatusItem : Swift.Decodable {
    public let isFollowing: Swift.Bool
    public let since: Foundation.Date?
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct RelationshipStatusResponse : Swift.Decodable {
    public let relationshipStatus: Swift.String?
    public let isFollowing: Swift.Bool
    public let isFollower: Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
  }
  public func checkBatchFollowingStatus(userIds: [Swift.String]) async throws -> [Swift.String : ContactsManager.SocialService.BatchFollowingStatusItem]
  public func follow(userId: Swift.String) async throws -> ContactsManager.FollowActionResponse
  public func unfollow(userId: Swift.String) async throws -> ContactsManager.FollowActionResponse
  public func isFollowing(userId: Swift.String) async throws -> ContactsManager.FollowStatusResponse
  public func getRelationshipStatus(userId: Swift.String) async throws -> ContactsManager.SocialService.RelationshipStatusResponse
  public func getFollowers(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedFollowList
  public func getFollowing(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedFollowList
  public func getMutualFollows(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedMutualFollowers
  public func createEvent(eventData: ContactsManager.CreateEventRequest) async throws -> ContactsManager.EventActionResponse
  public func getEvent(eventId: Swift.String) async throws -> ContactsManager.SocialEvent
  public func updateEvent(eventId: Swift.String, eventData: ContactsManager.UpdateEventRequest) async throws -> ContactsManager.EventActionResponse
  public func deleteEvent(eventId: Swift.String) async throws -> ContactsManager.EventActionResponse
  public func getUserEvents(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getFeed(matching: ContactsManager.FeedMatchingType = .following, eventType: ContactsManager.SocialEventType?, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getFeed(matching: ContactsManager.FeedMatchingType = .following, eventType: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  @available(*, deprecated, message: "Use getFeed(matching:eventType:skip:limit:) instead for more flexible event filtering")
  public func getUpcomingEvents(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  @available(*, deprecated, message: "Use getFeed(matching:kind:skip:limit:) instead")
  public func getForYouFeed(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  @objc deinit
}
extension ContactsManager.SocialService {
  public func react(eventId: Swift.String, reactionType: ContactsManager.ReactionType, metadata: ContactsManager.ReactionMetadata? = nil) async throws -> ContactsManager.ReactionActionResponse
  public func react(eventId: Swift.String, reactionType: Swift.String, metadata: ContactsManager.ReactionMetadata? = nil) async throws -> ContactsManager.ReactionActionResponse
  public func updateReaction(eventId: Swift.String, reactionType: ContactsManager.ReactionType?, metadata: ContactsManager.ReactionMetadata? = nil) async throws -> ContactsManager.ReactionActionResponse
  public func updateReaction(eventId: Swift.String, reactionType: Swift.String?, metadata: ContactsManager.ReactionMetadata? = nil) async throws -> ContactsManager.ReactionActionResponse
  public func removeReaction(eventId: Swift.String) async throws -> ContactsManager.ReactionActionResponse
  public func getReactions(eventId: Swift.String, skip: Swift.Int = 0, limit: Swift.Int = 50) async throws -> ContactsManager.PaginatedReactionsList
  public func getReactionsSummary(eventId: Swift.String) async throws -> ContactsManager.EventReactionsSummary
  public func getMyReaction(eventId: Swift.String) async throws -> ContactsManager.ReactionType?
  public func getUserReaction(eventId: Swift.String, userId: Swift.String) async throws -> ContactsManager.ReactionType?
  public func getEventWithReactions(eventId: Swift.String) async throws -> ContactsManager.EventWithReactions
  public func getBatchUserReactions(eventIds: [Swift.String]) async throws -> [Swift.String : ContactsManager.ReactionType?]
  public func getUserEvents(userId: Swift.String? = nil, reactionTypes: [ContactsManager.ReactionType]? = nil, includeReactions: Swift.Bool = false, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getUserEvents(userId: Swift.String? = nil, reactionTypes: [Swift.String]? = nil, includeReactions: Swift.Bool = false, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getFeedWithReactions(matching: ContactsManager.FeedMatchingType = .following, eventType: ContactsManager.SocialEventType? = nil, includeReactions: Swift.Bool = true, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
}
public enum ContactSelectionMode {
  case single
  case multiple
  public static func == (a: ContactsManager.ContactSelectionMode, b: ContactsManager.ContactSelectionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ContactFieldType {
  case notes
  case phone
  case email
  case any
  public static func == (a: ContactsManager.ContactFieldType, b: ContactsManager.ContactFieldType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactSelectionOptions {
  public let selectionMode: ContactsManager.ContactSelectionMode
  public let fieldType: ContactsManager.ContactFieldType
  public let maxSelectionCount: Swift.Int?
  public init(selectionMode: ContactsManager.ContactSelectionMode = .single, fieldType: ContactsManager.ContactFieldType = .any, maxSelectionCount: Swift.Int? = nil)
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public class ContactsManagerUI {
  public static func getInstance() -> ContactsManager.ContactsManagerUI
  @_Concurrency.MainActor public func searchContacts(from viewController: UIKit.UIViewController, options: ContactsManager.ContactSelectionOptions, completion: @escaping (Swift.Result<[ContactsManager.CMContact], any Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct SyncMetrics {
  public let totalDeviceContacts: Swift.Int
  public let newContacts: Swift.Int
  public let updatedContacts: Swift.Int
  public let unchangedContacts: Swift.Int
  public let deletedContacts: Swift.Int
  public let totalProcessed: Swift.Int
  public init(totalDeviceContacts: Swift.Int, newContacts: Swift.Int, updatedContacts: Swift.Int, unchangedContacts: Swift.Int, deletedContacts: Swift.Int, totalProcessed: Swift.Int)
}
public typealias ContactSyncCompletionHandler = (ContactsManager.SyncMetrics) -> Swift.Void
public enum ContactsServiceError : Foundation.LocalizedError {
  case invalidAPIKey
  case apiKeyValidationFailed(Swift.String)
  case networkError(any Swift.Error)
  case initializationFailed(any Swift.Error)
  case databaseError(any Swift.Error)
  case notInitialized
  case contactsAccessDenied
  case userNotAuthenticated
  case invalidUserInfo(Swift.String)
  case customError(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactsService {
  public static let shared: ContactsManager.ContactsService
  final public var onContactsSynced: ContactsManager.ContactSyncCompletionHandler?
  final public var autoSyncEnabled: Swift.Bool {
    get
    set
  }
  final public var social: ContactsManager.SocialService? {
    get
  }
  final public var people: ContactsManager.PeopleService? {
    get
  }
  final public var invites: ContactsManager.InviteService? {
    get
  }
  final public func initialize(withAPIKey apiKey: Swift.String, token: Swift.String? = nil, userInfo: ContactsManager.UserInfo, options: ContactsManager.ContactsManagerOptions = .default) async throws
  final public func initialize(withToken token: Swift.String, options: ContactsManager.ContactsManagerOptions = .default) async throws
  final public var isInitialized: Swift.Bool {
    get
  }
  final public var currentState: Swift.String {
    get
  }
  final public func reset() async throws
  final public func uninitialize() async throws
  final public var settingsAlert: some SwiftUICore.View {
    get
  }
  @objc deinit
}
extension ContactsManager.ContactsService {
  final public func requestContactsAccess() async -> Swift.Bool
  final public var contactsAccessStatus: ContactsManager.ContactsAccessStatus {
    get
  }
  final public func hasContactsReadAccess() -> Swift.Bool
}
extension ContactsManager.ContactsService {
  final public func getCurrentCMUser() async throws -> ContactsManager.CMUser
}
extension ContactsManager.ContactsService {
  public static func checkHealth() async -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class InviteService {
  public var code: Swift.String? {
    get async
  }
  public var link: Swift.String? {
    get async
  }
  public func validateCode(code: Swift.String) async -> ContactsManager.ValidateInviteCodeResponse?
  public func remaining() async -> Swift.Int
  public func invited() async -> [ContactsManager.Contact]
  public func invitedBy() async -> ContactsManager.Contact?
  public func redeemInvite(code inviteCode: Swift.String, for redeemerId: Swift.String) async -> Swift.Bool
  public func getInviteDetails(for code: Swift.String) async -> ContactsManager.ValidateInviteCodeResponse?
  public func createInvite() async -> ContactsManager.InviteResponse?
  public func sendBulkInviteEmails(contacts: [ContactsManager.Contact], emailBody: Swift.String) async -> ContactsManager.BulkInviteEmailResponse?
  public func isBulkInviteEmailAvailable() async -> Swift.Bool
  @objc deinit
}
public enum ContactMatchingCriteria {
  case contactsInApp
  case usersWithMyContact
  case suggestedInvite
  case all
  public static func == (a: ContactsManager.ContactMatchingCriteria, b: ContactsManager.ContactMatchingCriteria) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class PeopleService {
  final public func fetchUsers(userIds: [Swift.String]) async throws -> [ContactsManager.Contact]
  final public func fetch(matching criteria: [ContactsManager.ContactMatchingCriteria], limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  @objc deinit
}
extension ContactsManager.PeopleService {
  final public func fetch(matching criterion: ContactsManager.ContactMatchingCriteria, limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  final public func fetchUsersInApp(limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  final public func fetchUsersYouMightKnow(limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  final public func fetchContactsToInvite(limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  final public func fetchContactsUsingApp(limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
  final public func fetchAllContacts(limit: Swift.Int = 10, skip: Swift.Int = 0) async throws -> [ContactsManager.Contact]
}
public enum RecommendationType {
  case inviteRecommendations
  case appUsers
  case usersYouMightKnow
  public static func == (a: ContactsManager.RecommendationType, b: ContactsManager.RecommendationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactRecommendation {
  public let contact: ContactsManager.CMContact
  public let score: Swift.Double
  public let reason: Swift.String
  public let type: ContactsManager.RecommendationType
  public let organizationUserId: Swift.String?
}
extension ContactsManager.FollowingStatus : Swift.Equatable {}
extension ContactsManager.FollowingStatus : Swift.Hashable {}
extension ContactsManager.FollowingStatus : Swift.RawRepresentable {}
extension ContactsManager.ContactDataRestriction : Swift.Equatable {}
extension ContactsManager.ContactDataRestriction : Swift.Hashable {}
extension ContactsManager.ContactDataRestriction : Swift.RawRepresentable {}
extension ContactsManager.SourceType : Swift.Equatable {}
extension ContactsManager.SourceType : Swift.Hashable {}
extension ContactsManager.SourceType : Swift.RawRepresentable {}
extension ContactsManager.FeedMatchingType : Swift.Equatable {}
extension ContactsManager.FeedMatchingType : Swift.Hashable {}
extension ContactsManager.FeedMatchingType : Swift.RawRepresentable {}
extension ContactsManager.SocialEventType : Swift.Equatable {}
extension ContactsManager.SocialEventType : Swift.Hashable {}
extension ContactsManager.SocialEventType : Swift.RawRepresentable {}
extension ContactsManager.RuntimeEnvironment : Swift.Equatable {}
extension ContactsManager.RuntimeEnvironment : Swift.Hashable {}
extension ContactsManager.RuntimeEnvironment : Swift.RawRepresentable {}
extension ContactsManager.ContactSyncManager.SyncError : Swift.Equatable {}
extension ContactsManager.ContactSyncManager.SyncError : Swift.Hashable {}
extension ContactsManager.ContactsAccessStatus : Swift.Hashable {}
extension ContactsManager.ContactSearchService.SearchField : Swift.Equatable {}
extension ContactsManager.ContactSearchService.SearchField : Swift.Hashable {}
extension ContactsManager.ContactsManagerEvent : Swift.Equatable {}
extension ContactsManager.ContactsManagerEvent : Swift.Hashable {}
extension ContactsManager.ContactsManagerEvent : Swift.RawRepresentable {}
extension ContactsManager.ContactSelectionMode : Swift.Equatable {}
extension ContactsManager.ContactSelectionMode : Swift.Hashable {}
extension ContactsManager.ContactFieldType : Swift.Equatable {}
extension ContactsManager.ContactFieldType : Swift.Hashable {}
extension ContactsManager.ContactMatchingCriteria : Swift.Equatable {}
extension ContactsManager.ContactMatchingCriteria : Swift.Hashable {}
extension ContactsManager.RecommendationType : Swift.Equatable {}
extension ContactsManager.RecommendationType : Swift.Hashable {}
