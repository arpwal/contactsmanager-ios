// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios18.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name ContactsManager
import BackgroundTasks
import Combine
import Contacts
@_exported import ContactsManager
import CryptoKit
import Foundation
import OSLog
import Observation
import Swift
import SwiftData
import SwiftUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _SwiftData_SwiftUI
public enum ContactDatabaseError : Swift.Error {
  case notInitialized
  case invalidModelContainer
  case contactNotFound
  case invalidData
  case searchError
  case operationFailed(Swift.String)
  case contextCreationFailed
}
public enum ContactSyncProperty {
  case sourceId(Swift.String)
  case parentContactId(Swift.String)
  case imageUrl(Swift.String)
  case bio(Swift.String)
  case location(Swift.String)
  case organizationName(Swift.String)
  case departmentName(Swift.String)
  case jobTitle(Swift.String)
  case notes(Swift.String)
  case interests([Swift.String])
  case avatars([Swift.String])
  case isDeleted(Swift.Bool)
}
extension ContactsManager.ContactsService {
  final public func enableBackgroundSync()
  final public func scheduleBackgroundSyncTask()
}
extension ContactsManager.ContactsService {
  final public func fetchContacts(fieldType: ContactsManager.ContactFieldType) async throws -> [ContactsManager.Contact]
  final public func fetchContact(withId id: Swift.String) async throws -> ContactsManager.Contact?
}
extension ContactsManager.ContactsService {
  final public func getSharedContactsByUsersToInvite(limit: Swift.Int = 30) async throws -> [ContactsManager.ContactRecommendation]
  final public func getContactsUsingApp(limit: Swift.Int = 30) async throws -> [ContactsManager.LocalCanonicalContact]
  final public func getUsersYouMightKnow(limit: Swift.Int = 30) async throws -> [ContactsManager.CanonicalContact]
}
extension ContactsManager.ContactsService {
  final public func syncContacts() async throws -> Swift.Int
}
public let SECTIONNONAME: Swift.String
final public class Contact {
  final public var identifier: Swift.String {
    get
    set
  }
  final public var id: Swift.String {
    get
  }
  final public var contactType: Swift.Int {
    get
    set
  }
  final public var namePrefix: Swift.String? {
    get
    set
  }
  final public var givenName: Swift.String? {
    get
    set
  }
  final public var middleName: Swift.String? {
    get
    set
  }
  final public var familyName: Swift.String? {
    get
    set
  }
  final public var previousFamilyName: Swift.String? {
    get
    set
  }
  final public var nameSuffix: Swift.String? {
    get
    set
  }
  final public var nickname: Swift.String? {
    get
    set
  }
  final public var contactSection: Swift.String? {
    get
    set
  }
  final public var displayName: Swift.String? {
    get
    set
  }
  final public var organizationName: Swift.String? {
    get
    set
  }
  final public var departmentName: Swift.String? {
    get
    set
  }
  final public var jobTitle: Swift.String? {
    get
    set
  }
  final public var notes: Swift.String? {
    get
    set
  }
  final public var bio: Swift.String? {
    get
    set
  }
  final public var location: Swift.String? {
    get
    set
  }
  final public var imageUrl: Swift.String? {
    get
    set
  }
  final public var imageData: Foundation.Data? {
    get
    set
  }
  final public var thumbnailImageData: Foundation.Data? {
    get
    set
  }
  final public var imageDataAvailable: Swift.Bool {
    get
    set
  }
  final public var phoneNumbers: [ContactsManager.ContactPhoneNumber] {
    get
    set
  }
  final public var emailAddresses: [ContactsManager.ContactEmailAddress] {
    get
    set
  }
  final public var urlAddresses: [ContactsManager.ContactURLAddress] {
    get
    set
  }
  final public var socialProfiles: [ContactsManager.ContactSocial] {
    get
    set
  }
  final public var addresses: [ContactsManager.ContactAddress] {
    get
    set
  }
  final public var instantMessageAddresses: [ContactsManager.ContactInstantMessage] {
    get
    set
  }
  final public var relations: [ContactsManager.ContactRelation] {
    get
    set
  }
  final public var interests: [Swift.String] {
    get
    set
  }
  final public var avatars: [Swift.String] {
    get
    set
  }
  final public var birthday: Foundation.Date? {
    get
    set
  }
  final public var dates: [ContactsManager.ContactDate] {
    get
    set
  }
  final public var createdAt: Swift.Double {
    get
    set
  }
  final public var matchString: Swift.String? {
    get
    set
  }
  final public var isDeleted: Swift.Bool {
    get
    set
  }
  final public var parentContactId: Swift.String? {
    get
    set
  }
  final public var lastSyncedAt: Swift.Double? {
    get
    set
  }
  final public var dirtyTime: Swift.Double? {
    get
    set
  }
  final public var sourceId: Swift.String? {
    get
    set
  }
  public init(identifier: Swift.String = UUID().uuidString, firstName: Swift.String? = nil, lastName: Swift.String? = nil, sourceId: Swift.String? = nil)
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.Contact> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.Contact>)
  @objc deinit
}
extension ContactsManager.Contact : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.Contact {
  final public var displayInfo: Swift.String {
    get
  }
}
extension ContactsManager.Contact : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.Contact : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactAddress : Swift.Comparable {
  final public var addressId: Swift.String {
    get
    set
  }
  final public var address1: Swift.String? {
    get
    set
  }
  final public var address2: Swift.String? {
    get
    set
  }
  final public var city: Swift.String? {
    get
    set
  }
  final public var county: Swift.String? {
    get
    set
  }
  final public var state: Swift.String? {
    get
    set
  }
  final public var country: Swift.String? {
    get
    set
  }
  final public var postalCode: Swift.String? {
    get
    set
  }
  final public var countryCode: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactAddress, rhs: ContactsManager.ContactAddress) -> Swift.Bool
  final public func display(separator: Swift.String = ", ") -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactAddress>)
  @objc deinit
}
extension ContactsManager.ContactAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactAddress : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactDate : Swift.Codable {
  final public var id: Swift.String {
    get
    set
  }
  final public var contactId: Swift.String {
    get
    set
  }
  final public var label: Swift.String {
    get
    set
  }
  final public var date: Foundation.Date {
    get
    set
  }
  final public var isPrimary: Swift.Bool {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  final public func displayString() -> Swift.String
  final public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactDate> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactDate>)
  @objc deinit
}
extension ContactsManager.ContactDate : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactDate : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactEmailAddress : Swift.Comparable {
  final public var emailId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactEmailAddress, rhs: ContactsManager.ContactEmailAddress) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactEmailAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactEmailAddress>)
  @objc deinit
}
extension ContactsManager.ContactEmailAddress : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactEmailAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactEmailAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactEmailAddress : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactInstantMessage : Swift.Comparable {
  final public var instantMessageId: Swift.String {
    get
    set
  }
  final public var service: Swift.String? {
    get
    set
  }
  final public var username: Swift.String? {
    get
    set
  }
  final public var userIdentifier: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactInstantMessage, rhs: ContactsManager.ContactInstantMessage) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactInstantMessage> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactInstantMessage>)
  @objc deinit
}
extension ContactsManager.ContactInstantMessage : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactInstantMessage : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactInstantMessage : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactPhoneNumber : Swift.Comparable {
  final public var phoneId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactPhoneNumber, rhs: ContactsManager.ContactPhoneNumber) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactPhoneNumber> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactPhoneNumber>)
  @objc deinit
}
extension ContactsManager.ContactPhoneNumber : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactPhoneNumber : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactPhoneNumber : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactPhoneNumber : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactRelation : Swift.Comparable {
  final public var relationId: Swift.String {
    get
    set
  }
  final public var name: Swift.String? {
    get
    set
  }
  final public var relationType: Swift.String? {
    get
    set
  }
  final public var notes: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactRelation, rhs: ContactsManager.ContactRelation) -> Swift.Bool
  final public func display() -> Swift.String
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactRelation> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactRelation>)
  @objc deinit
}
extension ContactsManager.ContactRelation : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactRelation : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactRelation : Observation.Observable {
}
public enum ContactDataRestriction : Swift.String, Swift.CaseIterable {
  case notes
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ContactsManager.ContactDataRestriction]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ContactsManager.ContactDataRestriction] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ContactsManagerOptions {
  public let restrictedKeysToFetch: Swift.Set<ContactsManager.ContactFieldType>
  public let verboseLogging: Swift.Bool
  public static let `default`: ContactsManager.ContactsManagerOptions
  public init(restrictedKeysToFetch: Swift.Set<ContactsManager.ContactFieldType> = [], verboseLogging: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers final public class ContactSocial : Swift.Comparable {
  final public var socialId: Swift.String {
    get
    set
  }
  final public var urlString: Swift.String? {
    get
    set
  }
  final public var username: Swift.String? {
    get
    set
  }
  final public var userIdentifier: Swift.String? {
    get
    set
  }
  final public var service: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactSocial, rhs: ContactsManager.ContactSocial) -> Swift.Bool
  final public func display() -> Swift.String?
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactSocial> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactSocial>)
  @objc deinit
}
extension ContactsManager.ContactSocial : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactSocial : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactSocial : Observation.Observable {
}
public enum SourceType : Swift.String, Swift.Codable {
  case google
  case outlook
  case csv
  case api
  case device
  case other
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactSource {
  final public var id: Swift.String {
    get
    set
  }
  final public var name: Swift.String {
    get
    set
  }
  final public var sourceType: Swift.String {
    get
    set
  }
  final public var organizationId: Swift.String {
    get
    set
  }
  final public var canonicalContactId: Swift.String {
    get
    set
  }
  final public var isActive: Swift.Bool {
    get
    set
  }
  final public var lastSyncAt: Swift.Double? {
    get
    set
  }
  final public var syncError: Swift.String? {
    get
    set
  }
  final public var credentialsJSON: Swift.String? {
    get
    set
  }
  final public var settingsJSON: Swift.String? {
    get
    set
  }
  final public var sourceMetadataJSON: Swift.String? {
    get
    set
  }
  final public var createdAt: Swift.Double {
    get
    set
  }
  final public var updatedAt: Swift.Double {
    get
    set
  }
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactSource> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactSource>)
  @objc deinit
}
extension ContactsManager.ContactSource : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactSource : SwiftData.PersistentModel {
  public typealias ID = Swift.String
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactSource : Observation.Observable {
}
@_hasMissingDesignatedInitializers final public class ContactURLAddress : Swift.Comparable {
  final public var urlId: Swift.String {
    get
    set
  }
  final public var value: Swift.String? {
    get
    set
  }
  final public var type: Swift.String? {
    get
    set
  }
  final public var emoji: Swift.String? {
    get
    set
  }
  final public var contact: ContactsManager.Contact? {
    get
    set
  }
  public static func < (lhs: ContactsManager.ContactURLAddress, rhs: ContactsManager.ContactURLAddress) -> Swift.Bool
  final public var persistentBackingData: any SwiftData.BackingData<ContactsManager.ContactURLAddress> {
    get
    set
  }
  public static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] {
    get
  }
  public init(backingData: any SwiftData.BackingData<ContactsManager.ContactURLAddress>)
  @objc deinit
}
extension ContactsManager.ContactURLAddress : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension ContactsManager.ContactURLAddress : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.ContactURLAddress : SwiftData.PersistentModel {
  public typealias ID = SwiftData.PersistentIdentifier
  final public var hashValue: Swift.Int {
    get
  }
}
extension ContactsManager.ContactURLAddress : Observation.Observable {
}
public struct DeviceInfo : Swift.Codable {
  public var deviceId: Swift.String
  public var hardwareId: Swift.String
  public var deviceName: Swift.String
  public var deviceModel: Swift.String
  public var deviceManufacturer: Swift.String
  public var deviceModelId: Swift.String
  public var osName: Swift.String
  public var osVersion: Swift.String
  public var screenWidth: Swift.Int
  public var screenHeight: Swift.Int
  public var screenDensity: CoreFoundation.CGFloat
  public var networkType: Swift.String
  public var appVersion: Swift.String
  public var appBuild: Swift.String
  public var appId: Swift.String
  public var locale: Swift.String
  public var timezone: Swift.String
  public var totalMemory: Swift.Int?
  public var cpuCount: Swift.Int?
  public var batteryLevel: Swift.Float?
  public var isCharging: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ContactsManager.DeviceInfo {
  public func asDictionary() -> [Swift.String : Any]
}
public struct SocialResponse<T> : Swift.Decodable where T : Swift.Decodable {
  public let status: Swift.String
  public let message: Swift.String?
  public let data: T
  public init(from decoder: any Swift.Decoder) throws
}
public struct LocalCanonicalContact : Swift.Decodable {
  public let contact: ContactsManager.Contact?
  public let contactId: Swift.String
  public let sourceContactId: Swift.String
  public let canonicalContact: ContactsManager.CanonicalContact
  public init(from decoder: any Swift.Decoder) throws
}
public struct CanonicalContact : Swift.Codable, Swift.Identifiable, Swift.Hashable {
  public let id: Swift.String
  public let organizationId: Swift.String?
  public let organizationUserId: Swift.String
  public let email: Swift.String?
  public let phone: Swift.String?
  public let fullName: Swift.String?
  public let avatarUrl: Swift.String?
  public let isActive: Swift.Bool?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public var contactMetadata: [Swift.String : Any]? {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public var displayInfo: Swift.String {
    get
  }
  public var initials: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ContactsManager.CanonicalContact, rhs: ContactsManager.CanonicalContact) -> Swift.Bool
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public struct FollowRelationship : Swift.Codable, Swift.Identifiable {
  public let id: Swift.String
  public let followerId: Swift.String
  public let followedId: Swift.String
  public let userId: Swift.String
  public let createdAt: Foundation.Date
  public let follower: ContactsManager.CanonicalContact?
  public let followed: ContactsManager.CanonicalContact?
  public var localContact: ContactsManager.Contact?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Swift.String
}
public struct FollowActionResponse : Swift.Decodable {
  public let alreadyFollowing: Swift.Bool?
  public let wasFollowing: Swift.Bool?
  public let success: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public struct FollowStatusResponse : Swift.Decodable {
  public let isFollowing: Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedFollowList : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public var items: [ContactsManager.FollowRelationship]
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedMutualFollowers : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public var items: [ContactsManager.CanonicalContact]
  public init(from decoder: any Swift.Decoder) throws
}
public struct SocialEvent : Swift.Codable, Swift.Identifiable {
  public let id: Swift.String
  public let organizationId: Swift.String
  public let canonicalContactId: Swift.String
  public let eventType: Swift.String
  public let title: Swift.String
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool
  public let createdAt: Foundation.Date
  public let updatedAt: Foundation.Date
  public let userId: Swift.String?
  public let createdBy: ContactsManager.EventCreator?
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EventCreator : Swift.Codable {
  public let name: Swift.String?
  public let avatarUrl: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CreateEventRequest : Swift.Codable {
  public let eventType: Swift.String
  public let title: Swift.String
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool
  public init(eventType: Swift.String, title: Swift.String, description: Swift.String? = nil, location: Swift.String? = nil, startTime: Foundation.Date? = nil, endTime: Foundation.Date? = nil, metadata: [Swift.String : Swift.String]? = nil, isPublic: Swift.Bool = true)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct UpdateEventRequest : Swift.Codable {
  public let title: Swift.String?
  public let description: Swift.String?
  public let location: Swift.String?
  public let startTime: Foundation.Date?
  public let endTime: Foundation.Date?
  public let metadata: [Swift.String : Swift.String]?
  public let isPublic: Swift.Bool?
  public init(title: Swift.String? = nil, description: Swift.String? = nil, location: Swift.String? = nil, startTime: Foundation.Date? = nil, endTime: Foundation.Date? = nil, metadata: [Swift.String : Swift.String]? = nil, isPublic: Swift.Bool? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EventActionResponse : Swift.Decodable {
  public let eventId: Swift.String?
  public let created: Swift.Bool?
  public let updated: Swift.Bool?
  public let deleted: Swift.Bool?
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaginatedEventList : Swift.Decodable {
  public let total: Swift.Int
  public let skip: Swift.Int
  public let limit: Swift.Int
  public let items: [ContactsManager.SocialEvent]
  public init(from decoder: any Swift.Decoder) throws
}
public class UserInfo : Swift.Codable {
  final public let userId: Swift.String
  final public let fullName: Swift.String?
  final public let email: Swift.String?
  final public let phone: Swift.String?
  final public let avatarUrl: Swift.String?
  final public let metadata: [Swift.String : Swift.String]?
  public init(userId: Swift.String, fullName: Swift.String? = nil, email: Swift.String? = nil, phone: Swift.String? = nil, avatarUrl: Swift.String? = nil, metadata: [Swift.String : Swift.String]? = nil)
  public func isValid() -> Swift.Bool
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum APIError : Swift.Error {
  case invalidURL
  case noData
  case decodingError
  case serverError(statusCode: Swift.Int, message: Swift.String)
  case networkError(any Swift.Error)
  case unauthorized
  case tokenExpired
  case unknownError
  public var localizedDescription: Swift.String {
    get
  }
}
public enum RuntimeEnvironment : Swift.String {
  case development
  case staging
  case production
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct APIConfig {
  public static var environment: ContactsManager.RuntimeEnvironment
  public static var baseURL: Foundation.URL {
    get
  }
  public static let apiVersion: Swift.String
  public static let contactsEndpoint: Swift.String
  public static let contactsSyncEndpoint: Swift.String
  public static let contactSourceEndpoint: Swift.String
  public static let userInfoEndpoint: Swift.String
  public static let sharedContactsToInviteEndpoint: Swift.String
  public static let appUserContactsEndpoint: Swift.String
  public static let usersYouMightKnowEndpoint: Swift.String
  public static let socialBasePath: Swift.String
  public static let followEndpoint: Swift.String
  public static let unfollowEndpoint: Swift.String
  public static let isFollowingEndpoint: Swift.String
  public static let followersEndpoint: Swift.String
  public static let followingEndpoint: Swift.String
  public static let mutualFollowsEndpoint: Swift.String
  public static let batchFollowingStatusEndpoint: Swift.String
  public static let eventsEndpoint: Swift.String
  public static let feedEndpoint: Swift.String
  public static let upcomingEventsEndpoint: Swift.String
  public static let forYouEndpoint: Swift.String
  public static let validateAPIKeyEndpoint: Swift.String
  public static let defaultTimeout: Swift.Double
  public static let uploadTimeout: Swift.Double
  public static let healthEndpoint: Swift.String
  public static let maxContactsPerBatch: Swift.Int
  public static let websiteURL: Swift.String
}
@_hasMissingDesignatedInitializers public class ContactSyncManager {
  public enum ContactSourceError : Swift.Error, Foundation.LocalizedError {
    case saveFailure(any Swift.Error)
    case retrievalFailure(Swift.String)
    case sourceNotFound
    case jsonEncodingFailure
    case jsonDecodingFailure
    public var errorDescription: Swift.String? {
      get
    }
  }
  @objc deinit
}
extension ContactsManager.ContactSyncManager {
  public enum SyncError : Swift.Error {
    case alreadyRunning
    case contextSaveError
    case sourceNotRegistered
    case organizationIdNotFound
    public var localizedDescription: Swift.String {
      get
    }
    public static func == (a: ContactsManager.ContactSyncManager.SyncError, b: ContactsManager.ContactSyncManager.SyncError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ContactDatabaseContainer {
  var mainContext: SwiftData.ModelContext { get }
}
extension SwiftData.ModelContainer : ContactsManager.ContactDatabaseContainer {
}
public enum ContactsAccessStatus : Swift.Equatable {
  case notDetermined
  case authorized
  case limitedAuthorized
  case denied
  case restricted
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ContactsManager.ContactsAccessStatus, b: ContactsManager.ContactsAccessStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactSearchService {
  public static let shared: ContactsManager.ContactSearchService
  final public func getTotalContactsCount() async throws -> Swift.Int
  @_Concurrency.MainActor final public func searchContacts(query: Swift.String, searchFields: Swift.Set<ContactsManager.ContactSearchService.SearchField> = Set(SearchField.allCases), offset: Swift.Int = 0, limit: Swift.Int = 50) async throws -> (contacts: [ContactsManager.Contact], totalCount: Swift.Int)
  @_Concurrency.MainActor final public func quickSearch(_ query: Swift.String) async throws -> [ContactsManager.Contact]
  public enum SearchField : Swift.CaseIterable {
    case name
    case email
    case phone
    case address
    case organization
    case notes
    public static func == (a: ContactsManager.ContactSearchService.SearchField, b: ContactsManager.ContactSearchService.SearchField) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [ContactsManager.ContactSearchService.SearchField]
    nonisolated public static var allCases: [ContactsManager.ContactSearchService.SearchField] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
public enum ContactsManagerEvent : Swift.String {
  case appDidBecomeActive
  case appDidEnterBackground
  case contactStoreDidChange
  case appWasTerminated
  case contactsAccessChanged
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias EventHandler = () -> Swift.Void
extension ContactsManager.ContactsManagerEvent : Swift.CaseIterable {
  public typealias AllCases = [ContactsManager.ContactsManagerEvent]
  nonisolated public static var allCases: [ContactsManager.ContactsManagerEvent] {
    get
  }
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func onContactsManagerEvent(_ event: ContactsManager.ContactsManagerEvent, identifier: Swift.String, perform action: @escaping () -> Swift.Void) -> some SwiftUICore.View
  
}
public enum SocialServiceError : Foundation.LocalizedError {
  case invalidInput(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class SocialService {
  public struct BatchFollowingStatusItem : Swift.Decodable {
    public let isFollowing: Swift.Bool
    public let since: Foundation.Date?
    public init(from decoder: any Swift.Decoder) throws
  }
  public func checkBatchFollowingStatus(userIds: [Swift.String]) async throws -> [Swift.String : ContactsManager.SocialService.BatchFollowingStatusItem]
  public func followUser(userId: Swift.String) async throws -> ContactsManager.FollowActionResponse
  public func unfollowUser(userId: Swift.String) async throws -> ContactsManager.FollowActionResponse
  public func isFollowingUser(userId: Swift.String) async throws -> ContactsManager.FollowStatusResponse
  public func getFollowers(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedFollowList
  public func getFollowing(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedFollowList
  public func getMutualFollows(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedMutualFollowers
  public func createEvent(eventData: ContactsManager.CreateEventRequest) async throws -> ContactsManager.EventActionResponse
  public func getEvent(eventId: Swift.String) async throws -> ContactsManager.SocialEvent
  public func updateEvent(eventId: Swift.String, eventData: ContactsManager.UpdateEventRequest) async throws -> ContactsManager.EventActionResponse
  public func deleteEvent(eventId: Swift.String) async throws -> ContactsManager.EventActionResponse
  public func getUserEvents(userId: Swift.String? = nil, skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getFeed(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getUpcomingEvents(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  public func getForYouFeed(skip: Swift.Int = 0, limit: Swift.Int = 20) async throws -> ContactsManager.PaginatedEventList
  @objc deinit
}
public enum ContactSelectionMode {
  case single
  case multiple
  public static func == (a: ContactsManager.ContactSelectionMode, b: ContactsManager.ContactSelectionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ContactFieldType {
  case notes
  case phone
  case email
  case any
  public static func == (a: ContactsManager.ContactFieldType, b: ContactsManager.ContactFieldType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactSelectionOptions {
  public let selectionMode: ContactsManager.ContactSelectionMode
  public let fieldType: ContactsManager.ContactFieldType
  public let maxSelectionCount: Swift.Int?
  public init(selectionMode: ContactsManager.ContactSelectionMode = .single, fieldType: ContactsManager.ContactFieldType = .any, maxSelectionCount: Swift.Int? = nil)
}
@_hasMissingDesignatedInitializers @available(iOS 13.0, *)
public class ContactsManagerUI {
  public static func getInstance() -> ContactsManager.ContactsManagerUI
  @_Concurrency.MainActor public func searchContacts(from viewController: UIKit.UIViewController, options: ContactsManager.ContactSelectionOptions, completion: @escaping (Swift.Result<[ContactsManager.Contact], any Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct SyncMetrics {
  public let totalDeviceContacts: Swift.Int
  public let newContacts: Swift.Int
  public let updatedContacts: Swift.Int
  public let unchangedContacts: Swift.Int
  public let deletedContacts: Swift.Int
  public let totalProcessed: Swift.Int
  public init(totalDeviceContacts: Swift.Int, newContacts: Swift.Int, updatedContacts: Swift.Int, unchangedContacts: Swift.Int, deletedContacts: Swift.Int, totalProcessed: Swift.Int)
}
public typealias ContactSyncCompletionHandler = (ContactsManager.SyncMetrics) -> Swift.Void
public enum ContactsServiceError : Foundation.LocalizedError {
  case invalidAPIKey
  case apiKeyValidationFailed(Swift.String)
  case networkError(any Swift.Error)
  case initializationFailed(any Swift.Error)
  case databaseError(any Swift.Error)
  case notInitialized
  case contactsAccessDenied
  case userNotAuthenticated
  case invalidUserInfo(Swift.String)
  case customError(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ContactsService {
  public static let shared: ContactsManager.ContactsService
  final public var onContactsSynced: ContactsManager.ContactSyncCompletionHandler?
  final public var socialService: ContactsManager.SocialService? {
    get
  }
  final public func initialize(withAPIKey apiKey: Swift.String, token: Swift.String, userInfo: ContactsManager.UserInfo, options: ContactsManager.ContactsManagerOptions = .default) async throws
  final public var isInitialized: Swift.Bool {
    get
  }
  final public var currentState: Swift.String {
    get
  }
  final public func reset() async throws
  final public var settingsAlert: some SwiftUICore.View {
    get
  }
  @objc deinit
}
extension ContactsManager.ContactsService {
  final public func requestContactsAccess() async -> Swift.Bool
  final public var contactsAccessStatus: ContactsManager.ContactsAccessStatus {
    get
  }
  final public func hasContactsReadAccess() -> Swift.Bool
}
extension ContactsManager.ContactsService {
  public static func checkHealth() async -> Swift.Bool
}
public enum RecommendationType {
  case inviteRecommendations
  case appUsers
  case usersYouMightKnow
  public static func == (a: ContactsManager.RecommendationType, b: ContactsManager.RecommendationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContactRecommendation {
  public let contact: ContactsManager.Contact
  public let score: Swift.Double
  public let reason: Swift.String
  public let type: ContactsManager.RecommendationType
  public let organizationUserId: Swift.String?
}
extension ContactsManager.ContactDataRestriction : Swift.Equatable {}
extension ContactsManager.ContactDataRestriction : Swift.Hashable {}
extension ContactsManager.ContactDataRestriction : Swift.RawRepresentable {}
extension ContactsManager.SourceType : Swift.Equatable {}
extension ContactsManager.SourceType : Swift.Hashable {}
extension ContactsManager.SourceType : Swift.RawRepresentable {}
extension ContactsManager.RuntimeEnvironment : Swift.Equatable {}
extension ContactsManager.RuntimeEnvironment : Swift.Hashable {}
extension ContactsManager.RuntimeEnvironment : Swift.RawRepresentable {}
extension ContactsManager.ContactSyncManager.SyncError : Swift.Equatable {}
extension ContactsManager.ContactSyncManager.SyncError : Swift.Hashable {}
extension ContactsManager.ContactsAccessStatus : Swift.Hashable {}
extension ContactsManager.ContactSearchService.SearchField : Swift.Equatable {}
extension ContactsManager.ContactSearchService.SearchField : Swift.Hashable {}
extension ContactsManager.ContactsManagerEvent : Swift.Equatable {}
extension ContactsManager.ContactsManagerEvent : Swift.Hashable {}
extension ContactsManager.ContactsManagerEvent : Swift.RawRepresentable {}
extension ContactsManager.ContactSelectionMode : Swift.Equatable {}
extension ContactsManager.ContactSelectionMode : Swift.Hashable {}
extension ContactsManager.ContactFieldType : Swift.Equatable {}
extension ContactsManager.ContactFieldType : Swift.Hashable {}
extension ContactsManager.RecommendationType : Swift.Equatable {}
extension ContactsManager.RecommendationType : Swift.Hashable {}
